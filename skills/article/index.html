
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../c/">
      
      
        <link rel="next" href="../book/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>文章 - fighter YYDS</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../mkdocs/css/no-footer.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="orange">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="http://fighteryyds.github.io/fy-blog/" title="fighter YYDS" class="md-header__button md-logo" aria-label="fighter YYDS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            fighter YYDS
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              文章
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="orange"  aria-label="切换至夜间模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换至夜间模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="orange"  aria-label="切换至日间模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换至日间模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../.." class="md-tabs__link">
          
  
  
    
  
  主页

        </a>
      </li>
    
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../Linux/" class="md-tabs__link">
          
  
  
    
  
  技术

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../kaoyan/questions/" class="md-tabs__link">
          
  
  
    
  
  考研

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="http://fighteryyds.github.io/fy-blog/" title="fighter YYDS" class="md-nav__button md-logo" aria-label="fighter YYDS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    fighter YYDS
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../.." class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    主页
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1" id="__nav_1_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            主页
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../youlian/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    友链
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    技术
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            技术
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Linux/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Linux
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../c/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    c语言
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    文章
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    文章
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      为什么要学习计算机系统基础:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#man" class="md-nav__link">
    <span class="md-ellipsis">
      初识man
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#git" class="md-nav__link">
    <span class="md-ellipsis">
      git快速入门
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mit" class="md-nav__link">
    <span class="md-ellipsis">
      MIT
    </span>
  </a>
  
    <nav class="md-nav" aria-label="MIT">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#shell" class="md-nav__link">
    <span class="md-ellipsis">
      课程概览与shell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_1" class="md-nav__link">
    <span class="md-ellipsis">
      Shell工具和脚本
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_2" class="md-nav__link">
    <span class="md-ellipsis">
      Shell工具
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vim" class="md-nav__link">
    <span class="md-ellipsis">
      编辑器(vim)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      数据整理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      命令行环境
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      版本控制
    </span>
  </a>
  
    <nav class="md-nav" aria-label="版本控制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      调试及性能分析
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      元编程
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      安全和密码学
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../book/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    书籍
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../git/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    github&git
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    考研
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            考研
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../kaoyan/questions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    题目
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../kaoyan/thinkings/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    思想
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      为什么要学习计算机系统基础:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#man" class="md-nav__link">
    <span class="md-ellipsis">
      初识man
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#git" class="md-nav__link">
    <span class="md-ellipsis">
      git快速入门
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mit" class="md-nav__link">
    <span class="md-ellipsis">
      MIT
    </span>
  </a>
  
    <nav class="md-nav" aria-label="MIT">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#shell" class="md-nav__link">
    <span class="md-ellipsis">
      课程概览与shell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_1" class="md-nav__link">
    <span class="md-ellipsis">
      Shell工具和脚本
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_2" class="md-nav__link">
    <span class="md-ellipsis">
      Shell工具
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vim" class="md-nav__link">
    <span class="md-ellipsis">
      编辑器(vim)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      数据整理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      命令行环境
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      版本控制
    </span>
  </a>
  
    <nav class="md-nav" aria-label="版本控制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      调试及性能分析
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      元编程
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      安全和密码学
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="_1">文章收获：</h1>
<h2 id="_2">为什么要学习计算机系统基础:</h2>
<p><img alt="123" src="fy-blog/docs/skills/article/86.jpg" /></p>
<ul>
<li>该文章主要强调了作为计算机专业的我们在计算机方面的优势就是拥有对计算机系统的整体认知和把握，正是因为这一优势，我们可以在编程相同的命题时，可以编出与其他人效率相差几十倍的代码。</li>
<li>之后这篇文章也强调了动手实践的重要性，很多时候学习时的效果与动手实践时的效果可以说是两码事。同时通过动手实践可以促进自己对知识的理解和掌握，二者是相互促进的关系。</li>
</ul>
<h2 id="man">初识man</h2>
<ul>
<li>作为Linux菜鸟，经常面对着一大堆陌生的命令和参数，我经常会无语</li>
</ul>
<p><img alt="123" src="111101.jpg" /></p>
<ul>
<li>这时我知道了可以找man帮忙，学会用man独立解决问题，于是我输入了</li>
</ul>
<pre><code>man man
</code></pre>
<ul>
<li><img alt="123" src="11111.jpg" /></li>
<li>进入了man的世界后，还是啥也不懂，于是按了h求寻求帮助（按q可以退出），这时我来到了新的世界，世界的起点是“SUMMARY OF LESS COMMANDS”,然后我按照初识man这篇文章的内容一步一步的在Linux中进行和学习</li>
<li><img alt="123" src="111102.jpg" /></li>
<li>我明白了那个像英文音标一样的符号代表了ctrl，然后我也尝试了使用j 和 10j 来分别向下一行和十行。</li>
<li><img alt="123" src="11113.jpg" /></li>
<li>使用j后</li>
<li><img alt="123" src="11114.jpg" /></li>
<li>使用10j以后</li>
<li><img alt="123" src="11115.jpg" /></li>
<li>然后开始使用搜索命令“/加你要搜索的关键词”</li>
<li><img alt="123" src="11116.jpg" /></li>
<li>它会将所有含有h 和 H 的地方做出标记</li>
<li><img alt="123" src="111103.jpg" /></li>
<li>然后在DESCRIPTION中了解到了manual分成9大类，每一个manual page属于都属于其中的某一类</li>
<li><img alt="123" src="11117.jpg" /></li>
<li>然后是为了看懂SYNOPSIS，先在OPTIONS中弄明白每个参数的含义，然后你通过刚刚学会的"/加关键词"，学会了快速标记你想找的参数并搭配n来更快的找到。</li>
<li><img alt="123" src="111104.jpg" /></li>
<li>我在OPTIONS中还是不太明白-k的意思，然后退出man并在命令行中输入:</li>
</ul>
<pre><code>man -k printf
</code></pre>
<ul>
<li><img alt="123" src="111112.jpg" /></li>
<li>查看printf（1）这个shell命令，输入：</li>
</ul>
<pre><code>man 1 printf
</code></pre>
<ul>
<li><img alt="123" src="111113.jpg" /></li>
<li>查看printf(3)这个库函数，输入:</li>
</ul>
<pre><code>man 3 printf
</code></pre>
<ul>
<li><img alt="123" src="111111.jpg" /></li>
<li>在掌握了man的用法后，我们应该经常来拜访ta，很多时候它可以为我们提供可靠的帮助：</li>
<li>通过这篇文章我们学会了：</li>
<li>1.阅读程序输出的提示</li>
<li>2.通过搜索来定位我关心的内容</li>
<li>3.动手实践是认识新事物的最好方法（一边看文章，一边动手学习）</li>
<li>4.要学会独立寻求帮助</li>
</ul>
<h2 id="git">git快速入门</h2>
<p>1.<mark>git</mark> (具有存档功能）能够让你在过去和未来中随意穿梭, 避免构思错误的悲剧降临你的身上.</p>
<p>2.1安装命令：</p>
<pre><code>apt-get install git
</code></pre>
<p>2.2安装后的配置命令（名字可以写自己的）：</p>
<pre><code>1|git config --global user.name &quot;Zhang San&quot;     # your name
2|git config --global user.email &quot;zhangsan@foo.com&quot; # your email
3|git config --global core.editor vim           # your favourite editor
4|git config --global color.ui true
</code></pre>
<p>3.下载此次实验提供的框架代码：</p>
<pre><code>git clone
</code></pre>
<p>如果想在别的实验/或者项目中使用git，应该先进行初始化：</p>
<pre><code>git init
</code></pre>
<p>4.查看目前所有的存档：</p>
<pre><code>git log
</code></pre>
<p>我的电脑展示：</p>
<p><img alt=" " src="11231.jpg" /></p>
<p>可以看出我有一个存档的记录在昨天晚上的22：31：02时刻，标题为“my first using git and practicing times”，因为是第一次使用，所有把它简单的存为练习题目。第一次使用这个命令，内容应该为空。</p>
<p>5.查看所有跟踪已跟踪文件命令（已跟踪的文件是存档文件的前身）：</p>
<pre><code>git status
</code></pre>
<p>查看是否有新的文件或已修改的文件未被跟踪, 若有, 则使用 <code>git add</code> 将文件加入跟踪列表, 例如</p>
<pre><code>git add filename
</code></pre>
<p>想要一次性添加所有当前目录下的文件，你可以使用：</p>
<pre><code>git add -A
</code></pre>
<p>但这样会出现弊端，它会将很多不必要的文件也进跟踪，第一个就是不需要使用的文件，第二个就是因为编译而产生的可执行的二进制文件（binary文件）编译后的binary文件其实是比较大的，要比源码大很多。其实只需要上传源代码即可。</p>
<p>6.<mark>gitignore</mark>这块有我的努力，有想知道它到底怎么用的，可以看一看</p>
<p>所以我仔细地查询了一下<code>.gitignore</code>（在这个文件里的文件名，会被跟踪忽略）的相关用法：</p>
<p>6.1.首先需要在你的工作区(项目的根目录)下建立一个名称为<code>gitignore</code>的文件，然后把想要忽略的文件名填进去，这样在<code>git status</code>和<code>git add</code>就会自动忽略在.<code>gitignore</code>中的文件名</p>
<p>命令1：</p>
<pre><code>touch .gitignore      隐藏文件 .gitignore（linux下以.开头的文件都是隐藏文件）
</code></pre>
<p>6.2.然后用vim进行编辑：</p>
<p><img alt=" " src="11244.jpg" /></p>
<p>可以看出我把名为<code>1124.c</code>的文件写入了其中，接下来就是见证<code>.gitignore</code>的效果的时刻：</p>
<p><img alt=" " src="11242.jpg" /></p>
<p><img alt=" " src="11243.jpg" /></p>
<p>可以看出我的<code>1124.c</code>文件被隐藏在了<code>.gitignore</code>中了.</p>
<p>其实<code>.gitignore</code>也有自己的语法可以在<code>github</code>上自己找也可以点击<a href="https://github.com/github/gitignore">语法</a>：</p>
<p>介绍一个常用的</p>
<pre><code># cat .gitignore
*.xml
*.log
*.apk
*.c
</code></pre>
<p><code>.gitignore</code>注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的<code>xml</code>文件,log文件和<code>apk</code>文件。</p>
<p><code>.gitignore</code>配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利。</p>
<p>7.存档：</p>
<p>7.1首先你需要使用 <code>git status</code> 查看是否有新的文件或已修改的文件未被跟踪, 若有, 则使用 <code>git add</code> 将文件加入跟踪列表</p>
<p>7.2然后使用命令:</p>
<pre><code>git commit     #将跟踪文件进行存档
</code></pre>
<p>8.读档：</p>
<p>首先使用 <code>git log</code> 来查看已有的存档, 并决定你需要回到哪个过去. 每一份存档都有一个<code>hash code</code>, 例如 <code>b87c512d10348fd8f1e32ddea8ec95f87215aaa5</code> , 你需要通过<code>hash code</code>来告诉 <code>git</code> 你希望读哪一个档. 使用以下命令进行读档:</p>
<pre><code class="language-text">git reset --hard b87c
</code></pre>
<p>其中 <code>b87c</code> 是上文hash code的前缀: 你不需要输入整个hash code. 这时你再看看你的代码, 你已经成功地回到了过去!但事实上, 在使用 <code>git reset</code> 的hard模式之前, 你需要再三确认选择的存档是不是你的真正目标. 如果你读入了一个较早的存档, 那么比这个存档新的所有记录都将被删除! 这意为着你不能随便回到"将来"了.</p>
<p>9.git分支<mark>太烧脑了哈哈哈</mark></p>
<p>使用git分支就可以在不同的时间节点之间来回随意穿梭，你可以以你存档的那个节点作为主分支，在此基础上不断开设新的分支，用来记录你在主分支基础上更新的内容，因为你可以在分支之间反复s横跳，所以你就可以来回穿梭于在主存档（主分支基础上）各个时间节点（分支）。</p>
<p>使用<code>git branch</code>来查看所有分支：</p>
<p><img alt=" " src="12245.jpg" /></p>
<p>可以看到有俩个分支，一个是1224，一个master,前者是407a下的分支，后者是主分支。</p>
<p>现在使用<code>git checkout 407a</code>进行读档，这时我将处于一个虚构的分支中，我可以查看407a存档的内容，也可以对内容进行修改，但是无法存档，需要使用命令<code>git checkout -B 分支名</code>来将修改结果保存到一个新的分支中，如果分支已存在，起内容将会被覆盖。</p>
<p>00:04时刻我终于明白这玩意怎么使用了：</p>
<p>1.首先<code>git checkout master</code>进入了主分支（我的407a的主分支，你也可以使用<code>git checkout 407a</code>进入）</p>
<p>2.然后我在这个虚构分支中，再找一个文件进行内容修改，我在zjx空文件中写入zjx666并保存,这个保存是跟<mark>存档一样的，需要输入命令</mark>(这个十分重要，一开始我以为只要在不同的分支里进行修改，这些修改就会是相互独立的，实际却不是,它是共享修改结果的，为这个问题我想了很久很久，所以需要十分注意，一定要将各个分支的修改分别进行新的<mark>存档 存档 存储</mark>)：</p>
<pre><code>1|git add zjx
2|git commit
</code></pre>
<p><img alt=" " src="11248.jpg" /></p>
<p>然后我再创建一个新的分支：</p>
<pre><code>git branch 1124c
</code></pre>
<p>看下图你会发现，当我使用命令<code>git checkout 1124c</code>进入别的分支后，甚至连zjx这个文件都没有，当我再使用命令git checkout master后，不仅有zjx里面还有内容zjx666。这说明了一个道理，各个分支直接相互独立，互不干涉，这样你就可以随时进入各个时间节点，就像平行时空一样！ </p>
<p><img alt=" " src="11249.jpg" /></p>
<h2 id="mit">MIT</h2>
<h3 id="shell">课程概览与shell</h3>
<p>​   1.动机</p>
<ul>
<li>
<p>计算机可以帮助我们解决重复性的工作，但其实我们也在重复性的使用计算机。</p>
</li>
<li>
<p>我们在使用工具时，实际上可能只利用了这些工具的很少一部分，就比如我对<code>tmux</code>的印象，一开始我以为它只是一个分屏工具，甚至我还觉得它没有<code>screen</code>好用,但当我真正好时间去学习如何使用它时，发现它是那么的好用，而且分屏也只是它的很小的卖点，它可以用来保留进程，还可以为同一个进程开多个窗口，同一个窗口可以开多个窗格。</p>
</li>
</ul>
<p>2.课程结构</p>
<p>本课程包含 11 个时长在一小时左右的讲座，每一个讲座都会关注一个特定的主题或者工具。</p>
<p>3.主题1：<code>The Shell</code></p>
<p>为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：<code>Shell</code>,它允许你执行程序，输入并获取某种半结构化的输出。</p>
<p>4.使用shell</p>
<p>bash:</p>
<pre><code>zjx@linux-OSCA:~$   #用户名为zjx@linux-OSCA 当前目录为~ $表示现在的身份不是root用户
</code></pre>
<p><img alt=" " src="131.png" /></p>
<ul>
<li>
<p>执行了 <code>date</code> 这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递 <em>参数</em> ：</p>
</li>
<li>
<p>上例中，我们让 shell 执行 echo ，同时指定参数 hello。</p>
</li>
<li>但是，shell 是如何知道去哪里寻找 <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在  shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是  shell 所了解的编程关键字，那么它会去咨询 <em>环境变量</em>  <code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</li>
</ul>
<p><img alt=" " src="132.png" /></p>
<p>如果希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理（<code>My\ Photos</code>）。</p>
<blockquote>
<p>2024年 01月 03日 星期三 16:22:15 CST</p>
</blockquote>
<p>哈哈，我突然搞懂了环境变量是个啥，一下子感觉都非常的简单。</p>
<pre><code>export MYSLIDE_HOME=/home/zjx/Documents/Repo/ppt_markdown
</code></pre>
<ul>
<li>
<p>export: 这是一个 shell 命令，用于设置或显示环境变量。在这里，它用于设置环境变量。</p>
</li>
<li>
<p><code>MYSLIDE_HOME</code>: 这是环境变量的名称。</p>
</li>
<li>
<p><code>/home/zjx/Documents/Repo/ppt_markdown</code>: 这是为环境变量 <code>MYSLIDE_HOME</code> 指定的值，即设置 <code>MYSLIDE_HOME</code>的路径<code>/home/zjx/Documents/Repo/ppt_markdown</code>。</p>
</li>
</ul>
<pre><code>export MYSLIDE_HOME=/home/zjx/Documents/Repo/ppt_markdown
export MYSLIDE_SCRIPT=$MYSLIDE_HOME/scripts
alias pptopen=&quot;$MYSLIDE_SCRIPT/open.sh $1&quot;
</code></pre>
<p>我知道了使用一个程序时，只需要输入它的绝对路径即可，我就想到了这个<code>pptgen</code>也是同样的道理,先利用<code>MYSLIDE_SCRIPT</code>环境变量提供路径，再执行shell脚本。</p>
<blockquote>
<p>以 .sh 结尾的文件通常是 Shell 脚本文件。这种文件包含一系列 Shell 命令，可以由操作系统的命令解释器（例如 Bash、sh、zsh 等）执行。 Shell 脚本被用于自动化和批处理任务，其中包含一系列要在终端中执行的命令。 Shell 脚本文件中的命令按顺序执行，可以包括变量、条件语句、循环等结构，使其具有较强的编程能力。</p>
</blockquote>
<p><code>Bash</code>（<code>Bourne Again SHell</code>）和 <code>Zsh</code>（<code>Z Shell</code>）都是类Unix系统中的命令行解释器，也被称为<code>shell</code>。<code>Shell</code>是用户与操作系统内核之间的接口，它允许用户通过命令行或脚本与操作系统进行交互。</p>
<p>Shell的主要功能包括：</p>
<ul>
<li>
<p>命令解释与执行： 用户可以通过Shell输入命令，Shell会解释并执行这些命令。</p>
</li>
<li>
<p>脚本编写： 用户可以编写Shell脚本，将一系列命令组织在一起以完成特定的任务。</p>
</li>
<li>
<p>环境控制： Shell可以设置和管理环境变量，影响系统和用户的行为。</p>
</li>
<li>
<p>文件操作： 用户可以使用Shell执行文件和目录的操作，如创建、删除、移动、复制等。</p>
</li>
</ul>
<p><code>Bash</code>是<code>Unix</code>和<code>Linuz</code>中最常用的默认<code>Shell</code>，而<code>Zsh</code>则是一个功能更丰富且用户友好的替代品。它们都支持命令行历史、自动补全、别名等功能，以提高用户在命令行环境中的效率和便利性。选择使用哪种Shell通常取决于个人偏好和需求。</p>
<p>学习shell的过程：</p>
<p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如： <code>C:\</code>）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都是 <em>相对路径</em> 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录：</p>
<p><img alt=" " src="191.png" /></p>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p>
<p>还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。 <code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<p><img alt=" " src="193.png" /></p>
<p>还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。 <code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<p><img alt=" " src="196.png" /></p>
<p><img alt=" " src="195.png" /></p>
<pre><code>$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 &gt; brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
</code></pre>
<p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 <code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p>
<p>明白这一点后，我们可以这样操作：</p>
<pre><code>$ echo 3 | sudo tee brightness
</code></pre>
<h3 id="shell_1">Shell工具和脚本</h3>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。 需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>
<p>Bash中的字符串通过<code>'</code> 和 <code>"</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>"</code>定义的字符串会将变量值进行替换。</p>
<p><img alt=" " src="197.png" /></p>
<ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<p><img alt=" " src="1101.png" /></p>
<p><img alt=" " src="1102.png" /></p>
<p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p>
<p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和 <code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路运算符（short-circuiting） 同一行的多个命令可以用<code>;</code>分隔。程序 <code>true</code> 的返回码永远是<code>0</code>，<code>false</code> 的返回码永远是<code>1</code>。让我们看几个例子<img alt=" " src="1103.png" /></p>
<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 <em>命令替换</em>（<em>command substitution</em>）实现。</p>
<p>当通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是<code>STDIN</code>传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</p>
<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>
<p><img alt=" " src="1104.png" /></p>
<p>在条件语句中，比较 <code>$?</code> 是否等于0。在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 <code>sh</code>。</p>
<p>shell的 <em>通配</em><code>（*globbing*)</code>:</p>
<ul>
<li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>{}</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
</ul>
<p><img alt=" " src="1111.png" />在 <code>shebang</code> 行中使用<code>env</code>命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高来您的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。 例如，使用了<code>env</code>的shebang看上去时这样的<code>#!/usr/bin/env python</code></p>
<blockquote>
<p><code>env</code>命令:</p>
</blockquote>
<p><code>env</code>是一个在Unix和类Unix系统中常见的命令，用于执行命令时设置环境变量。环境变量是一种在操作系统中存储配置信息的机制，它们对于控制程序的行为和设置运行时参数非常重要。</p>
<p><code>env</code>命令的基本语法如下：</p>
<pre><code>env [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]
</code></pre>
<p>其中，<code>NAME=VALUE</code>是要设置的环境变量，COMMAND是要执行的命令，<code>ARG</code>是命令的参数。</p>
<p>例如，你可以使用<code>env</code>命令来设置环境变量并运行一个程序，如下所示：</p>
<pre><code>env VAR1=value1 VAR2=value2 myprogram
</code></pre>
<p>这将使用<code>env</code>命令设置<code>VAR1</code>和<code>VAR2</code>环境变量的值，然后运行<code>myprogram</code>。这样做的好处是可以在不修改脚本或程序本身的情况下，通过命令行灵活地更改环境变量的值。</p>
<p>请注意，<code>env</code>命令也可以用于简化脚本的开头，以确保脚本在不同系统上的兼容性，因为它可以帮助找到系统中的正确解释器。例如，在脚本的开头使用<code>#!/usr/bin/env python</code>可以确保使用系统中安装的<code>Python</code>解释器运行脚本，而不是硬编码特定的解释器路径。</p>
<blockquote>
<p>shell函数与脚本的区别：</p>
</blockquote>
<ul>
<li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>
<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>
<li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <code>export</code>将环境变量导出，并将值传递给环境变量。</li>
<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li>
</ul>
<blockquote>
<p>export命令用于将变量设置为环境变量，使其在当前会话中及其子进程中可用。以下是使用export命令的一些示例：</p>
</blockquote>
<p><img alt=" " src="1112.png" /></p>
<h3 id="shell_2">Shell工具</h3>
<p>查看命令如何使用（使用这个命令行并找出它的不同的选项）：</p>
<ul>
<li>可以使用-h或者--help</li>
<li>可以使用man,查看手册（manual）</li>
</ul>
<blockquote>
<p>查找文件</p>
</blockquote>
<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为 <code>find</code>的工具，它是 shell 上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p>
<p><img alt="" src="1113.png" /></p>
<blockquote>
<p>查找代码</p>
</blockquote>
<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p>
<p><mark>这里的<code>rg</code>指的是<code>ripgrep</code>，使用apt包是下载不了的，所以我今天第一次使用了新的安装包，就是为Mac专门服务的<code>Homebrew</code>.有了它我就能下百分之八十以上的应用了。</mark></p>
<p><img alt=" " src="1118.png" /></p>
<blockquote>
<p>查找shell命令</p>
</blockquote>
<p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p>
<p><img alt=" " src="1114.png" /></p>
<p>可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。<mark>下面是我在<code>bash</code>和<code>zsh</code>进行的新的配置。</mark></p>
<p><img alt="" src="1115.png" /></p>
<p><img alt=" " src="1116.png" /></p>
<p>以下就是用<code>Homebrew</code>安装包下载工具的截图</p>
<p><img alt=" " src="1117.png" /></p>
<blockquote>
<p>文件夹导航</p>
</blockquote>
<p>可以下载<code>fasd</code>工具或者<code>autojump</code>.</p>
<h2 id="vim">编辑器(vim)</h2>
<blockquote>
<p>vim的优点：</p>
</blockquote>
<ul>
<li>
<p>它对于插入文字和操纵文字有不同的模式。</p>
</li>
<li>
<p>Vim 是可编程的（可以使用 <code>Vimscript</code>即扩展vim的脚本语言 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一个程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。</p>
</li>
<li>
<p>Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用 上下左右键因为那样需要太多的手指移动。</p>
</li>
</ul>
<blockquote>
<p>编辑模式：</p>
</blockquote>
<ul>
<li><strong>正常模式</strong>：在文件中四处移动光标进行修改</li>
<li><strong>插入模式</strong>：插入文本</li>
<li><strong>替换模式</strong>：替换文本</li>
<li><strong>可视化模式</strong>（一般，行，块）：选中文本块</li>
<li><strong>命令模式</strong>：用于执行命令</li>
<li>
<p><mark>在不同的操作模式下，键盘敲击的含义也不同。比如，<code>x</code> 在插入模式会插入字母 <code>x</code>，但是在正常模式 会删除当前光标所在的字母，在可视模式下则会删除选中文块。</mark></p>
</li>
<li>
<p>可以按下 <code>&lt;ESC&gt;</code>（退出键）从任何其他模式返回正常模式。在正常模式，键入 <code>i</code> 进入插入 模式，<code>R</code> 进入替换模式，<code>v</code> 进入可视（一般）模式，<code>V</code> 进入可视（行）模式，<code>&lt;C-v&gt;</code> （<code>Ctrl-V</code>, 有时也写作 <code>^V</code>）进入可视（块）模式，<code>:</code> 进入命令模式。</p>
</li>
</ul>
<blockquote>
<p>命令行：</p>
</blockquote>
<ul>
<li>
<p><code>:q</code> 退出（关闭窗口）</p>
</li>
<li>
<p><code>:w</code> 保存（写）</p>
</li>
<li>
<p><code>:wq</code> 保存然后退出</p>
</li>
<li>
<p><code>:e {文件名}</code> 打开要编辑的文件</p>
</li>
<li>
<p><code>:ls</code> 显示打开的缓存</p>
</li>
<li>
<p><code>plaintext
  :help {标题}</code></p>
</li>
</ul>
<p>打开帮助文档    </p>
<ul>
<li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档</li>
<li><code>:help w</code> 打开 <code>w</code> 移动的帮助文档</li>
</ul>
<blockquote>
<p>移动：</p>
</blockquote>
<p>基本移动: <code>hjkl</code> （左， 下， 上， 右）</p>
<p>文件： <code>gg</code> （文件头）， <code>G</code> （文件尾）</p>
<p>词： <code>w</code> （下一个词）， <code>b</code> （词初）， <code>e</code> （词尾）</p>
<p>行： <code>0</code> （行初）， <code>^</code> （第一个非空格字符）， <code>$</code> （行尾）</p>
<blockquote>
<p>编辑：</p>
</blockquote>
<p><code>d{移动命令}</code> 删除 {移动命令}</p>
<p><code>x</code> 删除字符（等同于 <code>dl</code>）</p>
<p><code>s</code> 替换字符（等同于 <code>xi</code>）</p>
<p>可视化模式 + 操作    </p>
<p>-选中文字, <code>d</code> 删除 或者 <code>c</code> 改变</p>
<p><code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做</p>
<p><code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code> 也会复制）</p>
<p><code>p</code> 粘贴</p>
<p><img alt=" " src="fy-blog/docs/skills/article/119.png" /></p>
<p><code>:e {文件名}</code> 打开要编辑的文件</p>
<p><img alt=" " src="../../../../../Pictures/Screenshots/1192.png" /></p>
<h2 id="_3">数据整理</h2>
<blockquote>
<p>sed</p>
</blockquote>
<p><img alt=" " src="1201.png" /></p>
<p>sed 是一种流文本编辑器，其名称来源于流编辑器（stream editor）的缩写。它在Unix、Linux和类Unix系统上广泛使用，用于对文本进行转换和处理。sed 的主要功能是根据一系列的编辑命令对输入文本进行处理，输出结果。</p>
<p><code>sed</code> 的基本用法是在命令行中调用它并提供一系列编辑命令，这些命令可以包括搜索替换、删除行、插入文本等操作。例如，以下是一个简单的 sed 命令，用于将文件中的所有 "apple" 替换为 "orange"：</p>
<pre><code>sed 's/apple/orange/g' input.txt &gt; output.txt
</code></pre>
<p>在这个例子中，s/apple/orange/g 是一个编辑命令，它告诉 <code>sed</code>在输入文本中查找所有的 "apple" 并将其替换为 "orange"。g 表示全局替换，即一行中的所有匹配项都会被替换。</p>
<p><code>sed</code>在命令行环境中非常强大，可以通过结合正则表达式和不同的编辑命令来执行复杂的文本处理任务。</p>
<blockquote>
<p>正则表达式</p>
</blockquote>
<p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： <code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是） <code>/</code>开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<ul>
<li><code>.</code>  除换行符之外的”任意单个字符”</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<p>回过头我们再看<code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含”Disconnected from “的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。</p>
<p><code>sed</code> 的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加<code>\</code>才能使其具有特殊含义。或者，您也可以添加<code>-E</code>选项来支持这些匹配。</p>
<p><code>*</code> 和 <code>+</code> 在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。</p>
<p>对于某些正则表达式的实现来说，您可以给 <code>*</code> 或 <code>+</code> 增加一个<code>?</code> 后缀使其变成非贪婪模式，但是很可惜 <code>sed</code> 并不支持该后缀。不过，我们可以切换到 perl 的命令行模式，该模式支持编写这样的正则表达式：</p>
<pre><code>perl -pe 's/.*?Disconnected from //'
</code></pre>
<hr />
<p>1.将文件流传入本地电脑上过滤文本内容：</p>
<pre><code>ssh myserver journalctl | grep sshd
</code></pre>
<p>2.我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式:</p>
<pre><code>ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' | less
</code></pre>
<p>3.我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 <code>less</code> 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p>
<pre><code>$ ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' &gt; ssh.log
$ less ssh.log
</code></pre>
<hr />
<blockquote>
<p>awk</p>
</blockquote>
<ul>
<li>
<p><code>awk</code> 其实是一种编程语言，只不过它碰巧非常善于处理文本。</p>
</li>
<li>
<p><code>awk</code> 是一种用于文本处理和报告生成的编程语言。它通常用于处理结构化文本数据，例如表格数据或日志文件。</p>
</li>
<li>
<p><code>awk</code>是一种解释性的编程语言，通常作为命令行工具在Unix、Linux和类Unix系统上使用。它读取文本文件，逐行扫描每一行，并根据用户提供的规则执行相应的操作。</p>
</li>
<li>
<p><code>awk</code> 的基本结构是模式-动作语句，其中模式用于匹配文本的某些部分，而动作语句则定义了匹配时要执行的操作。</p>
</li>
</ul>
<h2 id="_4">命令行环境</h2>
<blockquote>
<p>结束进程：</p>
</blockquote>
<p><code>Ctrl+C或者kill -TERM &lt;PID&gt;</code></p>
<blockquote>
<p>暂停和后台执行进程:</p>
</blockquote>
<p><code>IGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的<code>SIGSTOP</code>）。</p>
<p>们可以使用 <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> 或 <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>
<p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a> 命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 找出 <code>pid</code>）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p>
<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p>
<p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code> ，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code> 。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p>
<blockquote>
<p>终端多路复用</p>
</blockquote>
<p>Tmux工具</p>
<blockquote>
<p>别名</p>
</blockquote>
<p>在shell的启动文件中添加，如.bashrc和.zshrc</p>
<pre><code>alias alias_name=&quot;command_to_alias arg1 arg2&quot;
</code></pre>
<blockquote>
<p>配置文件</p>
</blockquote>
<p>很多程序的配置都是通过纯文本格式的被称作<em>点文件</em>的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p>
<p>对于 <code>bash</code>来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>
<blockquote>
<p>管理配置文件</p>
</blockquote>
<p>它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p>
<ul>
<li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li>
<li><strong>可移植性</strong>: 您的工具在任何地方都以相同的配置工作</li>
<li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li>
<li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li>
</ul>
<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p>
<pre><code># Test if ~/.aliases exists and source it
if [ -f ~/.aliases ]; then
    source ~/.aliases
fi
</code></pre>
<blockquote>
<p>远程设备</p>
</blockquote>
<p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全 shell（SSH）。和其他工具一样，SSH 也是可以高度定制的，也值得我们花时间学习它。</p>
<blockquote>
<p>通过SSH复制文件</p>
</blockquote>
<p>使用 ssh 复制文件有很多方法：</p>
<ul>
<li><code>ssh+tee</code>, 最简单的方法是执行 <code>ssh</code> 命令，然后通过这样的方法利用标准输入实现 <code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<a href="https://www.man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a> 命令会将标准输出写入到一个文件；</li>
<li><a href="https://www.man7.org/linux/man-pages/man1/scp.1.html"><code>scp</code></a> ：当需要拷贝大量的文件或目录时，使用<code>scp</code> 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；</li>
<li><a href="https://www.man7.org/linux/man-pages/man1/rsync.1.html"><code>rsync</code></a> 对 <code>scp</code> 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 <code>--partial</code>标记实现断点续传。<code>rsync</code> 的语法和<code>scp</code>类似；</li>
</ul>
<h2 id="_5">版本控制</h2>
<blockquote>
<p>Git的数据模型：</p>
</blockquote>
<ul>
<li>
<p>数据对象:文件</p>
</li>
<li>
<p>树：目录</p>
</li>
<li>
<p>在 Git 中，历史记录是一个由快照组成的有向无环图。</p>
</li>
<li>
<p>Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。</p>
</li>
<li>
<p>在 Git 中，这些快照被称为“提交”。</p>
</li>
</ul>
<blockquote>
<p>Git的命令行接口</p>
</blockquote>
<p>基础：</p>
<ul>
<li><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</li>
<li><code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</li>
<li><code>git status</code>: 显示当前的仓库状态</li>
<li><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</li>
<li>git commit: 创建一个新的提交    </li>
<li><code>git log</code>: 显示历史日志</li>
<li><code>git log --all --graph --decorate</code>: 可视化历史记录（有向无环图）</li>
<li><code>git diff &lt;filename&gt;</code>: 显示与暂存区文件的差异</li>
<li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: 显示某个文件两个版本之间的差异</li>
<li><code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</li>
</ul>
<p>分支与合并：</p>
<ul>
<li>
<p><code>git branch</code>: 显示分支</p>
</li>
<li>
<p><code>git branch &lt;name&gt;</code>: 创建分支</p>
</li>
<li>
<p><code>plaintext
  git checkout -b &lt;name&gt;</code></p>
</li>
</ul>
<p>: 创建分支并切换到该分支    </p>
<ul>
<li>
<p>相当于 <code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></p>
</li>
<li>
<p><code>git merge &lt;revision&gt;</code>: 合并到当前分支</p>
</li>
<li>
<p><code>git mergetool</code>: 使用工具来处理合并冲突</p>
</li>
<li>
<p><code>git rebase</code>: 将一系列补丁变基（<code>rebase</code>）为新的基线</p>
</li>
</ul>
<p>撤销：</p>
<ul>
<li><code>git commit --amend</code>: 编辑提交的内容或信息</li>
<li><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li>
<li><code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li>
<li><code>git restore</code>:<code>git2.32</code>版本后取代git reset 进行许多撤销操作</li>
</ul>
<h3 id="_6">调试及性能分析</h3>
<blockquote>
<p>调试代码</p>
</blockquote>
<p>打印调试法与日志：</p>
<p>调试代码的第一种方法往往是在您发现问题的地方添加一些打印语句，然后不断重复此过程直到您获取了足够的信息并找到问题的根本原因。</p>
<p>另外一个方法是使用日志，而不是临时添加打印语句。日志较普通的打印语句有如下的一些优势：</p>
<ul>
<li>您可以将日志写入文件、socket 或者甚至是发送到远端服务器而不仅仅是标准输出；</li>
<li>日志可以支持严重等级（例如 INFO, DEBUG, WARN, ERROR等)，这使您可以根据需要过滤日志；</li>
<li>对于新发现的问题，很可能您的日志中已经包含了可以帮助您定位问题的足够的信息。</li>
<li>以彩色文本显示终端信息时可读性更好:</li>
</ul>
<p><img alt=" " src="1211.png" /></p>
<blockquote>
<p>第三方日志系统:</p>
</blockquote>
<p>目前，系统开始使用 <strong>system log</strong>，您所有的日志都会保存在这里。大多数（但不是全部的）Linux 系统都会使用 <code>systemd</code>，这是一个系统守护进程，它会控制您系统中的很多东西，例如哪些服务应该启动并运行。<code>systemd</code> 会将日志以某种特殊格式存放于<code>/var/log/journal</code>，您可以使用 <a href="http://man7.org/linux/man-pages/man1/journalctl.1.html"><code>journalctl</code></a> 命令显示这些消息。</p>
<p><img alt=" " src="1213.png" /></p>
<blockquote>
<p>调速器:</p>
</blockquote>
<p>当通过打印已经不能满足您的调试需求时，您应该使用调试器。</p>
<p>调试器是一种可以允许我们和正在执行的程序进行交互的程序，它可以做到：</p>
<ul>
<li>当到达某一行时将程序暂停；</li>
<li>一次一条指令地逐步执行程序；</li>
<li>程序崩溃后查看变量的值；</li>
<li>满足特定条件时暂停程序；</li>
<li>其他高级功能。</li>
</ul>
<blockquote>
<p>专门工具：</p>
</blockquote>
<p>即使您需要调试的程序是一个二进制的黑盒程序，仍然有一些工具可以帮助到您。当您的程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用 <a href="https://en.wikipedia.org/wiki/System_call">系统调用</a>。有一些命令可以帮助您追踪您的程序执行的系统调用。在 Linux 中可以使用<a href="http://man7.org/linux/man-pages/man1/strace.1.html"><code>strace</code></a> .</p>
<p>下面的例子展现来如何使用 <code>strace</code> 或 <code>dtruss</code> 来显示<code>ls</code> 执行时，对<a href="http://man7.org/linux/man-pages/man2/stat.2.html"><code>stat</code></a> 系统调用进行追踪对结果。若需要深入了解 <code>strace</code>，<a href="https://blogs.oracle.com/linux/strace-the-sysadmins-microscope-v2">这篇文章</a> 值得一读。</p>
<p><img alt=" " src="1212.png" /></p>
<blockquote>
<p>静态分析</p>
</blockquote>
<p>有些问题是您不需要执行代码就能发现的。例如，仔细观察一段代码，您就能发现某个循环变量覆盖了某个已经存在的变量或函数名；或是有个变量在被读取之前并没有被定义。 这种情况下 <a href="https://en.wikipedia.org/wiki/Static_program_analysis">静态分析</a> 工具就可以帮我们找到问题。静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。</p>
<blockquote>
<p>性能分析</p>
</blockquote>
<p>计时：</p>
<p>通常来说，用户时间+系统时间代表了您的进程所消耗的实际 CPU </p>
<ul>
<li>真实时间 - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I/O或网络）；</li>
<li><em>User</em> - CPU 执行用户代码所花费的时间；</li>
<li><em>Sys</em> - CPU 执行系统内核代码所花费的时间。</li>
</ul>
<p>例如，试着执行一个用于发起 HTTP 请求的命令并在其前面添加 <a href="http://man7.org/linux/man-pages/man1/time.1.html"><code>time</code></a> 前缀。网络不好的情况下您可能会看到下面的输出结果。请求花费了 <code>2s</code> 才完成，但是进程仅花费了 <code>15ms</code> 的 CPU 用户时间和 <code>12ms</code> 的 CPU 内核时间。</p>
<pre><code>$ time curl https://missing.csail.mit.edu &amp;&gt; /dev/null
real    0m2.561s
user    0m0.015s
sys     0m0.012s
</code></pre>
<p>性能分析工具（profilers）</p>
<blockquote>
<p><code>cpu</code></p>
</blockquote>
<p>大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU 性能分析工具。 CPU 性能分析工具有两种： 追踪分析器（<em>tracing</em>）及采样分析器（<em>sampling</em>）。 追踪分析器 会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）您的程序并记录程序堆栈。它们使用这些记录来生成统计信息，显示程序在哪些事情上花费了最多的时间。如果您希望了解更多相关信息，可以参考<a href="https://jvns.ca/blog/2017/12/17/how-do-ruby---python-profilers-work-">这篇</a> 介绍性的文章。</p>
<blockquote>
<p>内存</p>
</blockquote>
<p>像 C 或者 C++ 这样的语言，内存泄漏会导致您的程序在使用完内存后不去释放它。为了应对内存类的 Bug，我们可以使用类似 <a href="https://valgrind.org/">Valgrind</a> 这样的工具来检查内存泄漏问题。</p>
<blockquote>
<p>事件分析</p>
</blockquote>
<p>在我们使用<code>strace</code>调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<a href="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a> 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p>
<p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（<code>livelocks</code>）。下面是关于常见命令的简介：</p>
<ul>
<li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li>
<li><code>perf stat COMMAND ARG1 ARG2</code> - 收集与某个进程或指令相关的事件；</li>
<li><code>perf record COMMAND ARG1 ARG2</code> - 记录命令执行的采样信息并将统计数据储存在<code>perf.data</code>中；</li>
<li><code>perf report</code> - 格式化并打印 <code>perf.data</code> 中的数据。</li>
</ul>
<blockquote>
<p>可视化</p>
</blockquote>
<p>使用分析器来分析真实的程序时，由于软件的复杂性，其输出结果中将包含大量的信息。人类是一种视觉动物，非常不善于阅读大量的文字。因此很多工具都提供了可视化分析器输出结果的功能。</p>
<p>对于采样分析器来说，常见的显示 CPU 分析数据的形式是 <a href="http://www.brendangregg.com/flamegraphs.html">火焰图</a>，火焰图会在 Y 轴显示函数调用关系，并在 X 轴显示其耗时的比例。火焰图同时还是可交互的，您可以深入程序的某一具体部分，并查看其栈追踪。</p>
<blockquote>
<p>资源监控</p>
</blockquote>
<p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p>
<p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。  </p>
<ul>
<li><strong>通用监控</strong> - 最流行的工具要数 <a href="https://htop.dev/"><code>htop</code></a>,了，它是 <a href="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a>的改进版。<code>htop</code> 可以显示当前运行进程的多种统计信息。<code>htop</code> 有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、 <code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。 还可以留意一下 <a href="https://nicolargo.github.io/glances/"><code>glances</code></a> ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <a href="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a> 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I/O、网络、 CPU 利用率、上下文切换等等；</li>
<li><strong>I/O 操作</strong> - <a href="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a> 可以显示实时 I/O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</li>
<li><strong>磁盘使用</strong> - <a href="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a> 可以显示每个分区的信息，而 <a href="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a> 则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk <strong>u</strong>sage）。<code>-h</code> 选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a>是一个交互性更好的 <code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；</li>
<li><strong>内存使用</strong> - <a href="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a> 可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code> 这样的工具来显示；</li>
</ul>
<p><img alt=" " src="1214.png" /></p>
<ul>
<li><strong>打开文件</strong> - <a href="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a>  可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</li>
<li><strong>网络连接和配置</strong> - <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a> 能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code> 常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用 <a href="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a> 命令。注意，<code>netstat</code> 和 <code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。</li>
<li><strong>网络使用</strong> -  <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <a href="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a> 是非常好的用于对网络占用进行监控的交互式命令行工具。</li>
</ul>
<blockquote>
<p>专用工具</p>
</blockquote>
<p>有时候，您只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。 类似 <code>hyperfine</code>这样的命令行可以帮您快速进行基准测试。例如，我们在 shell 工具和脚本那一节课中我们推荐使用 <code>fd</code> 来代替 <code>find</code>。我们这里可以用<code>hyperfine</code>来比较一下它们。</p>
<p><img alt=" " src="1215.png" /></p>
<pre><code>$ hyperfine --warmup 3 'fd -e jpg' 'find . -iname &quot;*.jpg&quot;'
Benchmark #1: fd -e jpg
  Time (mean ± σ):      51.4 ms ±   2.9 ms    [User: 121.0 ms, System: 160.5 ms]
  Range (min … max):    44.2 ms …  60.1 ms    56 runs

Benchmark #2: find . -iname &quot;*.jpg&quot;
  Time (mean ± σ):      1.126 s ±  0.101 s    [User: 141.1 ms, System: 956.1 ms]
  Range (min … max):    0.975 s …  1.287 s    10 runs

Summary
  'fd -e jpg' ran
   21.89 ± 2.33 times faster than 'find . -iname &quot;*.jpg&quot;'
</code></pre>
<p>我们可以看到<code>fd</code> 比 <code>find</code> 要快20倍。</p>
<h2 id="_7">元编程</h2>
<blockquote>
<p>构建系统</p>
</blockquote>
<ul>
<li>
<p>对于大多数系统来说，不论其是否包含代码，都会包含一个“构建过程”。有时，您需要执行一系列操作。通常，这一过程包含了很多步骤，很多分支。执行一些命令来生成图表，然后执行另外的一些命令生成结果，然后再执行其他的命令来生成最终的论文。有很多事情需要我们完成，您并不是第一个因此感到苦恼的人，幸运的是，有很多工具可以帮助我们完成这些操作。</p>
</li>
<li>
<p>这些工具通常被称为 “构建系统”，而且这些工具还不少。</p>
</li>
<li>
<p><code>make</code> 是最常用的构建系统之一，您会发现它通常被安装到了几乎所有基于UNIX的系统中。<code>make</code>并不完美，但是对于中小型项目来说，它已经足够好了。当您执行 <code>make</code> 时，它会去参考当前目录下名为 <code>Makefile</code> 的文件。所有构建目标、相关依赖和规则都需要在该文件中定义，它看上去是这样的：</p>
</li>
</ul>
<pre><code>paper.pdf: paper.tex plot-data.png
    pdflatex paper.tex

plot-%.png: %.dat plot.py
    ./plot.py -i $*.dat -o $@
</code></pre>
<ul>
<li>
<p>冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖。缩进的部分是从依赖构建目标时需要用到的一段命令。在 <code>make</code> 中，第一条指令还指明了构建的目的，如果您使用不带参数的 <code>make</code>，这便是我们最终的构建结果。或者，您可以使用这样的命令来构建其他目标：<code>make plot-data.png</code>。</p>
</li>
<li>
<p>当我们执行 <code>make</code> 时会发生什么？</p>
</li>
</ul>
<pre><code>$ make
./plot.py -i data.dat -o plot-data.png
pdflatex paper.tex
... lots of output ...
</code></pre>
<ul>
<li>
<p>看！<code>PDF</code> ！</p>
</li>
<li>
<p>如果再次执行 <code>make</code> 会怎样？</p>
</li>
</ul>
<pre><code>$ make
make: 'paper.pdf' is up to date.
</code></pre>
<p>它进行了更新！</p>
<blockquote>
<p>依赖管理</p>
</blockquote>
<p>就您的项目来说，它的依赖可能本身也是其他的项目。您也许会依赖某些程序(例如 <code>python</code>)、系统包 (例如 <code>openssl</code>)或相关编程语言的库(例如 <code>matplotlib</code>)。 现在，大多数的依赖可以通过某些<strong>软件仓库</strong>来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖。例如 <code>Ubuntu</code> 系统下面有<code>Ubuntu</code>软件包仓库，您可以通过<code>apt</code> 这个工具来访问</p>
<p>由于每个仓库、每种工具的运行机制都不太一样，因此我们并不会在本节课深入讲解具体的细节。我们会介绍一些通用的术语，例如<em>版本控制</em>。大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个<em>版本号</em>。通常看上去像 8.1.3 或  64.1.20192004。版本号一般是数字构成的，但也并不绝对。版本号有很多用途，其中最重要的作用是保证软件能够运行。试想一下，假如我的库要发布一个新版本，在这个版本里面我重命名了某个函数。如果有人在我的库升级版本后，仍希望基于它构建新的软件，那么很可能构建会失败，因为它希望调用的函数已经不复存在了。有了版本控制就可以很好的解决这个问题，我们可以指定当前项目需要基于某个版本，甚至某个范围内的版本，或是某些项目来构建。这么做的话，即使某个被依赖的库发生了变化，依赖它的软件可以基于其之前的版本进行构建。</p>
<p>版本号包含多个部分的原因:</p>
<p>不同项目所用的版本号其具体含义并不完全相同，但是一个相对比较常用的标准是<a href="https://semver.org/">语义版本号</a>，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。相关规则有：</p>
<ul>
<li>如果新的版本没有改变 <code>API</code>，请将补丁号递增；</li>
<li>如果您添加了 <code>API</code> 并且该改动是向后兼容的，请将次版本号递增；</li>
<li>如果您修改了 <code>API</code> 但是它并不向后兼容，请将主版本号递增。</li>
</ul>
<p>您应该知道，Python 2 和 Python 3 的代码是不兼容的，这也是为什么 Python 的主版本号改变的原因。类似的，使用 Python 3.5 编写的代码在 3.7 上可以运行，但是在 3.4 上可能会不行。</p>
<p>如果我依赖的版本是<code>1.3.7</code>，那么使用<code>1.3.8</code>、<code>1.6.1</code>，甚至是<code>1.3.0</code>都是可以的。如果版本号是 <code>2.2.4</code> 就不一定能用了，因为它的主版本号增加了。</p>
<p>使用依赖管理系统的时候，您可能会遇到锁文件（<em>lock files</em>）这一概念。锁文件列出了您当前每个依赖所对应的具体版本号。通常，您需要执行升级程序才能更新依赖的版本。这么做的原因有很多，例如避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本（可能会包含 bug）。还有一种极端的依赖锁定叫做 <code>vendoring</code>，它会把您的依赖中的所有代码直接拷贝到您的项目中，这样您就能够完全掌控代码的任何修改，同时您也可以将自己的修改添加进去，不过这也意味着如果该依赖的维护者更新了某些代码，您也必须要自己去拉取这些更新。</p>
<blockquote>
<p>持续集成系统</p>
</blockquote>
<p>持续集成，或者叫做 CI 是一种雨伞术语（umbrella  term，涵盖了一组术语的术语），它指的是那些“当您的代码变动时，自动运行的东西”，市场上有很多提供各式各样 CI  工具的公司，这些工具大部分都是免费或开源的。比较大的有 Travis CI、Azure Pipelines 和 <code>GitHub  Actions</code>。它们的工作原理都是类似的：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。目前为止，最常见的规则是：如果有人提交代码，执行测试套件。当这个事件被触发时，CI  提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。您可以进行某些设置，这样当测试套件失败时您能够收到通知或者当测试全部通过时，您的仓库主页会显示一个徽标。</p>
<blockquote>
<p>测试简介</p>
</blockquote>
<ul>
<li>测试套件：所有测试的统称。</li>
<li>单元测试：一种“微型测试”，用于对某个封装的特性进行测试。</li>
<li>集成测试：一种“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能<em>协同</em>工作。</li>
<li>回归测试：一种实现特定模式的测试，用于保证之前引起问题的 bug 不会再次出现。</li>
<li>模拟（Mocking）: 使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会“模拟网络连接” 或 “模拟硬盘”。</li>
</ul>
<h2 id="_8">安全和密码学</h2>
<blockquote>
<p>熵</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">熵</a>(Entropy) 度量了不确定性并可以用来决定密码的强度。</p>
<p>熵的单位是 <em>比特</em>。对于一个均匀分布的随机离散变量，熵等于<code>log_2(所有可能的个数，即n)</code>。 扔一次硬币的熵是1比特。掷一次（六面）骰子的熵大约为2.58比特。</p>
<p>使用多少比特的熵取决于应用的威胁模型。</p>
<p>大约40比特的熵足以对抗在线穷举攻击（受限于网络速度和应用认证机制）。 而对于离线穷举攻击（主要受限于计算速度）, 一般需要更强的密码 (比如80比特或更多)。</p>
<blockquote>
<p>散列函数</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">密码散列函数</a> (Cryptographic hash function) 可以将任意大小的数据映射为一个固定大小的输出。除此之外，还有一些其他特性。  一个散列函数的大概规范如下：</p>
<pre><code>hash(value: array&lt;byte&gt;) -&gt; vector&lt;byte, N&gt;  (N对于该函数固定)
</code></pre>
<p>一个散列函数拥有以下特性：</p>
<ul>
<li>确定性：对于不变的输入永远有相同的输出。</li>
<li>不可逆性：对于<code>hash(m) = h</code>，难以通过已知的输出<code>h</code>来计算出原始输入<code>m</code>。</li>
<li>目标碰撞抵抗性/弱无碰撞：对于一个给定输入<code>m_1</code>，难以找到<code>m_2 != m_1</code>且<code>hash(m_1) = hash(m_2)</code>。</li>
<li>碰撞抵抗性/强无碰撞：难以找到一组满足<code>hash(m_1) = hash(m_2)</code>的输入<code>m_1, m_2</code>（该性质严格强于目标碰撞抵抗性）。</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a>是Git中使用的一种散列函数， 它可以将任意大小的输入映射为一个160比特（可被40位十六进制数表示）的输出。 下面我们用<code>sha1sum</code>命令来测试SHA1对几个字符串的输出：</p>
<pre><code>$ printf 'hello' | sha1sum
aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d
$ printf 'hello' | sha1sum
aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d
$ printf 'Hello' | sha1sum 
f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0
</code></pre>
<blockquote>
<p>密码散列函数的应用</p>
</blockquote>
<ul>
<li>Git中的内容寻址存储(Content-addressed storage)：<a href="https://en.wikipedia.org/wiki/Hash_function">散列函数</a>是一个宽泛的概念（存在非密码学的散列函数），那么Git为什么要特意使用密码散列函数？</li>
<li>文件的信息摘要(Message digest)：像Linux ISO这样的软件可以从非官方的（有时不太可信的）镜像站下载，所以需要设法确认下载的软件和官方一致。 官方网站一般会在（指向镜像站的）下载链接旁边备注安装文件的哈希值。 用户从镜像站下载安装文件后可以对照公布的哈希值来确定安装文件没有被篡改。</li>
<li><a href="https://en.wikipedia.org/wiki/Commitment_scheme">承诺机制</a>(Commitment scheme)： 假设我希望承诺一个值，但之后再透露它——  比如在没有一个可信的、双方可见的硬币的情况下在我的脑海中公平的“扔一次硬币”。 我可以选择一个值<code>r = random()</code>，并和你分享它的哈希值<code>h = sha256(r)</code>。 这时你可以开始猜硬币的正反：我们一致同意偶数<code>r</code>代表正面，奇数<code>r</code>代表反面。 你猜完了以后，我告诉你值<code>r</code>的内容，得出胜负。同时你可以使用<code>sha256(r)</code>来检查我分享的哈希值<code>h</code>以确认我没有作弊。</li>
</ul>
<blockquote>
<p>对称加密与非对称加密：</p>
</blockquote>
<p>密钥数量：</p>
<ul>
<li>
<p>对称加密： 使用相同的密钥进行加密和解密，这个密钥称为对称密钥或私钥。因为同一个密钥用于加密和解密，所以在分发密钥时需要确保安全性。</p>
</li>
<li>
<p>非对称加密： 使用一对密钥，一个是公钥用于加密，另一个是私钥用于解密。公钥可以公开分发，而私钥必须保持安全。任何拥有公钥的人都可以使用它加密信息，但只有持有相应私钥的人才能解密。</p>
</li>
</ul>
<p>加密解密过程：</p>
<ul>
<li>
<p>对称加密： 同一个密钥用于加密和解密。加密和解密过程非常快速，因为只涉及一个密钥。常见的对称加密算法包括 <code>DES</code>、<code>AES</code> 和 <code>3DES</code>。</p>
</li>
<li>
<p>非对称加密： 使用公钥加密的信息只能由相应的私钥解密，反之亦然。加密和解密的过程较慢，因为涉及到复杂的数学运算。常见的非对称加密算法包括 <code>RSA</code>、<code>DSA</code> 和<code>ECC</code>。</p>
</li>
</ul>
<p>密钥管理：</p>
<ul>
<li>
<p>对称加密： 密钥的分发和管理可能更复杂，因为需要确保对称密钥的安全传递。如果密钥在传递的过程中被拦截，整个通信链路可能会受到威胁。</p>
</li>
<li>
<p>非对称加密： 公钥可以自由分发，而私钥必须被安全地保护。这样就避免了在密钥传递过程中的一些问题，但需要确保私钥的安全性。</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>
<p>对称加密： 由于效率高，通常用于大量数据的加密，例如数据库加密、文件加密等。但密钥管理可能成为一个挑战。</p>
</li>
<li>
<p>非对称加密： 用于小块数据的加密，例如数字签名、密钥交换等。由于安全性高，经常用于保护对称密钥的传递，例如 <code>SSL/TLS</code> 协议。</p>
</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023-现在 张佳昕
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
    <a href="https://github.com/fighteryyds" target="_blank" rel="noopener" title="GitHub | fighteryyds" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.top", "navigation.indexes", "navigation.expand", "search.suggest", "search.highlight"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>