# 文章收获：

## 为什么要学习计算机系统基础:

![123](article/86.jpg)

- 该文章主要强调了作为计算机专业的我们在计算机方面的优势就是拥有对计算机系统的整体认知和把握，正是因为这一优势，我们可以在编程相同的命题时，可以编出与其他人效率相差几十倍的代码。
- 之后这篇文章也强调了动手实践的重要性，很多时候学习时的效果与动手实践时的效果可以说是两码事。同时通过动手实践可以促进自己对知识的理解和掌握，二者是相互促进的关系。

## 初识man

- 作为Linux菜鸟，经常面对着一大堆陌生的命令和参数，我经常会无语

![123](article/111101.jpg)

- 这时我知道了可以找man帮忙，学会用man独立解决问题，于是我输入了

```
man man
```

- ![123](article/11111.jpg)
- 进入了man的世界后，还是啥也不懂，于是按了h求寻求帮助（按q可以退出），这时我来到了新的世界，世界的起点是“SUMMARY OF LESS COMMANDS”,然后我按照初识man这篇文章的内容一步一步的在Linux中进行和学习
- ![123](article/111102.jpg)
- 我明白了那个像英文音标一样的符号代表了ctrl，然后我也尝试了使用j 和 10j 来分别向下一行和十行。
- ![123](article/11113.jpg)
- 使用j后
- ![123](article/11114.jpg)
- 使用10j以后
- ![123](article/11115.jpg)
- 然后开始使用搜索命令“/加你要搜索的关键词”
- ![123](article/11116.jpg)
- 它会将所有含有h 和 H 的地方做出标记
- ![123](article/111103.jpg)
- 然后在DESCRIPTION中了解到了manual分成9大类，每一个manual page属于都属于其中的某一类
- ![123](article/11117.jpg)
- 然后是为了看懂SYNOPSIS，先在OPTIONS中弄明白每个参数的含义，然后你通过刚刚学会的"/加关键词"，学会了快速标记你想找的参数并搭配n来更快的找到。
- ![123](article/111104.jpg)
- 我在OPTIONS中还是不太明白-k的意思，然后退出man并在命令行中输入:

```
man -k printf
```

- ![123](article/111112.jpg)
- 查看printf（1）这个shell命令，输入：

```
man 1 printf
```

- ![123](article/111113.jpg)
- 查看printf(3)这个库函数，输入:

``` 
man 3 printf
```

- ![123](article/111111.jpg)
- 在掌握了man的用法后，我们应该经常来拜访ta，很多时候它可以为我们提供可靠的帮助：
- 通过这篇文章我们学会了：
- 1.阅读程序输出的提示
- 2.通过搜索来定位我关心的内容
- 3.动手实践是认识新事物的最好方法（一边看文章，一边动手学习）
- 4.要学会独立寻求帮助

## git快速入门

1.<mark>git</mark> (具有存档功能）能够让你在过去和未来中随意穿梭, 避免构思错误的悲剧降临你的身上.

2.1安装命令：

```
apt-get install git
```

2.2安装后的配置命令（名字可以写自己的）：

```
1|git config --global user.name "Zhang San"		# your name
2|git config --global user.email "zhangsan@foo.com"	# your email
3|git config --global core.editor vim			# your favourite editor
4|git config --global color.ui true
```

3.下载此次实验提供的框架代码：

```
git clone
```

如果想在别的实验/或者项目中使用git，应该先进行初始化：

```
git init
```

4.查看目前所有的存档：

```
git log
```

我的电脑展示：

![ ](article/11231.jpg)

可以看出我有一个存档的记录在昨天晚上的22：31：02时刻，标题为“my first using git and practicing times”，因为是第一次使用，所有把它简单的存为练习题目。第一次使用这个命令，内容应该为空。

5.查看所有跟踪已跟踪文件命令（已跟踪的文件是存档文件的前身）：

```
git status
```

查看是否有新的文件或已修改的文件未被跟踪, 若有, 则使用 `git add` 将文件加入跟踪列表, 例如

```
git add filename
```

想要一次性添加所有当前目录下的文件，你可以使用：

```
git add -A
```

但这样会出现弊端，它会将很多不必要的文件也进跟踪，第一个就是不需要使用的文件，第二个就是因为编译而产生的可执行的二进制文件（binary文件）编译后的binary文件其实是比较大的，要比源码大很多。其实只需要上传源代码即可。

6.<mark>gitignore</mark>这块有我的努力，有想知道它到底怎么用的，可以看一看

所以我仔细地查询了一下`.gitignore`（在这个文件里的文件名，会被跟踪忽略）的相关用法：

6.1.首先需要在你的工作区(项目的根目录)下建立一个名称为`gitignore`的文件，然后把想要忽略的文件名填进去，这样在`git status`和`git add`就会自动忽略在.`gitignore`中的文件名

命令1：

```
touch .gitignore      隐藏文件 .gitignore（linux下以.开头的文件都是隐藏文件）
```

6.2.然后用vim进行编辑：

![ ](article/11244.jpg)

可以看出我把名为`1124.c`的文件写入了其中，接下来就是见证`.gitignore`的效果的时刻：

![ ](article/11242.jpg)

![ ](article/11243.jpg)

可以看出我的`1124.c`文件被隐藏在了`.gitignore`中了.

其实`.gitignore`也有自己的语法可以在`github`上自己找也可以点击[语法](https://github.com/github/gitignore)：

介绍一个常用的

```
# cat .gitignore
*.xml
*.log
*.apk
*.c
```

`.gitignore`注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的`xml`文件,log文件和`apk`文件。

`.gitignore`配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利。

7.存档：

7.1首先你需要使用 `git status` 查看是否有新的文件或已修改的文件未被跟踪, 若有, 则使用 `git add` 将文件加入跟踪列表

7.2然后使用命令:

```
git commit     #将跟踪文件进行存档
```

8.读档：

首先使用 `git log` 来查看已有的存档, 并决定你需要回到哪个过去. 每一份存档都有一个`hash code`, 例如 `b87c512d10348fd8f1e32ddea8ec95f87215aaa5` , 你需要通过`hash code`来告诉 `git` 你希望读哪一个档. 使用以下命令进行读档:

```text
git reset --hard b87c
```

其中 `b87c` 是上文hash code的前缀: 你不需要输入整个hash code. 这时你再看看你的代码, 你已经成功地回到了过去!但事实上, 在使用 `git reset` 的hard模式之前, 你需要再三确认选择的存档是不是你的真正目标. 如果你读入了一个较早的存档, 那么比这个存档新的所有记录都将被删除! 这意为着你不能随便回到"将来"了.

 9.git分支<mark>太烧脑了哈哈哈</mark>

使用git分支就可以在不同的时间节点之间来回随意穿梭，你可以以你存档的那个节点作为主分支，在此基础上不断开设新的分支，用来记录你在主分支基础上更新的内容，因为你可以在分支之间反复横跳，所以你就可以来回穿梭于在主存档（主分支基础上）各个时间节点（分支）。

使用`git branch`来查看所有分支：

<img src="article/12245.jpg" width="50%" alt="图片">

可以看到有俩个分支，一个是1224，一个master,前者是407a下的分支，后者是主分支。

现在使用`git checkout 407a`进行读档，这时我将处于一个虚构的分支中，我可以查看407a存档的内容，也可以对内容进行修改，但是无法存档，需要使用命令`git checkout -B 分支名`来将修改结果保存到一个新的分支中，如果分支已存在，起内容将会被覆盖。

00:04时刻我终于明白这玩意怎么使用了：

1.首先`git checkout master`进入了主分支（我的407a的主分支，你也可以使用`git checkout 407a`进入）

2.然后我在这个虚构分支中，再找一个文件进行内容修改，我在zjx空文件中写入zjx666并保存,这个保存是跟<mark>存档一样的，需要输入命令</mark>(这个十分重要，一开始我以为只要在不同的分支里进行修改，这些修改就会是相互独立的，实际却不是,它是共享修改结果的，为这个问题我想了很久很久，所以需要十分注意，一定要将各个分支的修改分别进行新的<mark>存档 存档 存储</mark>)：

```
1|git add zjx
2|git commit
```

![ ](article/11248.jpg)

然后我再创建一个新的分支：

```
git branch 1124c
```

看下图你会发现，当我使用命令`git checkout 1124c`进入别的分支后，甚至连zjx这个文件都没有，当我再使用命令git checkout master后，不仅有zjx里面还有内容zjx666。这说明了一个道理，各个分支直接相互独立，互不干涉，这样你就可以随时进入各个时间节点，就像平行时空一样！ 

![ ](article/11249.jpg)