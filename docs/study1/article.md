# 文章收获：

## 为什么要学习计算机系统基础:

![123](article/86.jpg)

- 该文章主要强调了作为计算机专业的我们在计算机方面的优势就是拥有对计算机系统的整体认知和把握，正是因为这一优势，我们可以在编程相同的命题时，可以编出与其他人效率相差几十倍的代码。
- 之后这篇文章也强调了动手实践的重要性，很多时候学习时的效果与动手实践时的效果可以说是两码事。同时通过动手实践可以促进自己对知识的理解和掌握，二者是相互促进的关系。

## 初识man

- 作为Linux菜鸟，经常面对着一大堆陌生的命令和参数，我经常会无语

![123](article/111101.jpg)

- 这时我知道了可以找man帮忙，学会用man独立解决问题，于是我输入了

```
man man
```

- ![123](article/11111.jpg)
- 进入了man的世界后，还是啥也不懂，于是按了h求寻求帮助（按q可以退出），这时我来到了新的世界，世界的起点是“SUMMARY OF LESS COMMANDS”,然后我按照初识man这篇文章的内容一步一步的在Linux中进行和学习
- ![123](article/111102.jpg)
- 我明白了那个像英文音标一样的符号代表了ctrl，然后我也尝试了使用j 和 10j 来分别向下一行和十行。
- ![123](article/11113.jpg)
- 使用j后
- ![123](article/11114.jpg)
- 使用10j以后
- ![123](article/11115.jpg)
- 然后开始使用搜索命令“/加你要搜索的关键词”
- ![123](article/11116.jpg)
- 它会将所有含有h 和 H 的地方做出标记
- ![123](article/111103.jpg)
- 然后在DESCRIPTION中了解到了manual分成9大类，每一个manual page属于都属于其中的某一类
- ![123](article/11117.jpg)
- 然后是为了看懂SYNOPSIS，先在OPTIONS中弄明白每个参数的含义，然后你通过刚刚学会的"/加关键词"，学会了快速标记你想找的参数并搭配n来更快的找到。
- ![123](article/111104.jpg)
- 我在OPTIONS中还是不太明白-k的意思，然后退出man并在命令行中输入:

```
man -k printf
```

- ![123](article/111112.jpg)
- 查看printf（1）这个shell命令，输入：

```
man 1 printf
```

- ![123](article/111113.jpg)
- 查看printf(3)这个库函数，输入:

``` 
man 3 printf
```

- ![123](article/111111.jpg)
- 在掌握了man的用法后，我们应该经常来拜访ta，很多时候它可以为我们提供可靠的帮助：
- 通过这篇文章我们学会了：
- 1.阅读程序输出的提示
- 2.通过搜索来定位我关心的内容
- 3.动手实践是认识新事物的最好方法（一边看文章，一边动手学习）
- 4.要学会独立寻求帮助

## git快速入门

1.<mark>git</mark> (具有存档功能）能够让你在过去和未来中随意穿梭, 避免构思错误的悲剧降临你的身上.

2.1安装命令：

```
apt-get install git
```

2.2安装后的配置命令（名字可以写自己的）：

```
1|git config --global user.name "Zhang San"		# your name
2|git config --global user.email "zhangsan@foo.com"	# your email
3|git config --global core.editor vim			# your favourite editor
4|git config --global color.ui true
```

3.下载此次实验提供的框架代码：

```
git clone
```

如果想在别的实验/或者项目中使用git，应该先进行初始化：

```
git init
```

4.查看目前所有的存档：

```
git log
```

我的电脑展示：

![ ](article/11231.jpg)

可以看出我有一个存档的记录在昨天晚上的22：31：02时刻，标题为“my first using git and practicing times”，因为是第一次使用，所有把它简单的存为练习题目。第一次使用这个命令，内容应该为空。

5.查看所有跟踪已跟踪文件命令（已跟踪的文件是存档文件的前身）：

```
git status
```

查看是否有新的文件或已修改的文件未被跟踪, 若有, 则使用 `git add` 将文件加入跟踪列表, 例如

```
git add filename
```

想要一次性添加所有当前目录下的文件，你可以使用：

```
git add -A
```

但这样会出现弊端，它会将很多不必要的文件也进跟踪，第一个就是不需要使用的文件，第二个就是因为编译而产生的可执行的二进制文件（binary文件）编译后的binary文件其实是比较大的，要比源码大很多。其实只需要上传源代码即可。

6.<mark>gitignore</mark>这块有我的努力，有想知道它到底怎么用的，可以看一看

所以我仔细地查询了一下`.gitignore`（在这个文件里的文件名，会被跟踪忽略）的相关用法：

6.1.首先需要在你的工作区(项目的根目录)下建立一个名称为`gitignore`的文件，然后把想要忽略的文件名填进去，这样在`git status`和`git add`就会自动忽略在.`gitignore`中的文件名

命令1：

```
touch .gitignore      隐藏文件 .gitignore（linux下以.开头的文件都是隐藏文件）
```

6.2.然后用vim进行编辑：

![ ](article/11244.jpg)

可以看出我把名为`1124.c`的文件写入了其中，接下来就是见证`.gitignore`的效果的时刻：

![ ](article/11242.jpg)

![ ](article/11243.jpg)

可以看出我的`1124.c`文件被隐藏在了`.gitignore`中了.

其实`.gitignore`也有自己的语法可以在`github`上自己找也可以点击[语法](https://github.com/github/gitignore)：

介绍一个常用的

```
# cat .gitignore
*.xml
*.log
*.apk
*.c
```

`.gitignore`注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的`xml`文件,log文件和`apk`文件。

`.gitignore`配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利。

7.存档：

7.1首先你需要使用 `git status` 查看是否有新的文件或已修改的文件未被跟踪, 若有, 则使用 `git add` 将文件加入跟踪列表

7.2然后使用命令:

```
git commit     #将跟踪文件进行存档
```

8.读档：

首先使用 `git log` 来查看已有的存档, 并决定你需要回到哪个过去. 每一份存档都有一个`hash code`, 例如 `b87c512d10348fd8f1e32ddea8ec95f87215aaa5` , 你需要通过`hash code`来告诉 `git` 你希望读哪一个档. 使用以下命令进行读档:

```text
git reset --hard b87c
```

其中 `b87c` 是上文hash code的前缀: 你不需要输入整个hash code. 这时你再看看你的代码, 你已经成功地回到了过去!但事实上, 在使用 `git reset` 的hard模式之前, 你需要再三确认选择的存档是不是你的真正目标. 如果你读入了一个较早的存档, 那么比这个存档新的所有记录都将被删除! 这意为着你不能随便回到"将来"了.

 9.git分支<mark>太烧脑了哈哈哈</mark>

使用git分支就可以在不同的时间节点之间来回随意穿梭，你可以以你存档的那个节点作为主分支，在此基础上不断开设新的分支，用来记录你在主分支基础上更新的内容，因为你可以在分支之间反复s横跳，所以你就可以来回穿梭于在主存档（主分支基础上）各个时间节点（分支）。

使用`git branch`来查看所有分支：

![ ](article/12245.jpg)

可以看到有俩个分支，一个是1224，一个master,前者是407a下的分支，后者是主分支。

现在使用`git checkout 407a`进行读档，这时我将处于一个虚构的分支中，我可以查看407a存档的内容，也可以对内容进行修改，但是无法存档，需要使用命令`git checkout -B 分支名`来将修改结果保存到一个新的分支中，如果分支已存在，起内容将会被覆盖。

00:04时刻我终于明白这玩意怎么使用了：

1.首先`git checkout master`进入了主分支（我的407a的主分支，你也可以使用`git checkout 407a`进入）

2.然后我在这个虚构分支中，再找一个文件进行内容修改，我在zjx空文件中写入zjx666并保存,这个保存是跟<mark>存档一样的，需要输入命令</mark>(这个十分重要，一开始我以为只要在不同的分支里进行修改，这些修改就会是相互独立的，实际却不是,它是共享修改结果的，为这个问题我想了很久很久，所以需要十分注意，一定要将各个分支的修改分别进行新的<mark>存档 存档 存储</mark>)：

```
1|git add zjx
2|git commit
```

![ ](article/11248.jpg)

然后我再创建一个新的分支：

```
git branch 1124c
```

看下图你会发现，当我使用命令`git checkout 1124c`进入别的分支后，甚至连zjx这个文件都没有，当我再使用命令git checkout master后，不仅有zjx里面还有内容zjx666。这说明了一个道理，各个分支直接相互独立，互不干涉，这样你就可以随时进入各个时间节点，就像平行时空一样！ 

![ ](article/11249.jpg)

## MIT

### 课程概览与shell

​	1.动机

- 计算机可以帮助我们解决重复性的工作，但其实我们也在重复性的使用计算机。

- 我们在使用工具时，实际上可能只利用了这些工具的很少一部分，就比如我对`tmux`的印象，一开始我以为它只是一个分屏工具，甚至我还觉得它没有`screen`好用,但当我真正好时间去学习如何使用它时，发现它是那么的好用，而且分屏也只是它的很小的卖点，它可以用来保留进程，还可以为同一个进程开多个窗口，同一个窗口可以开多个窗格。

2.课程结构

本课程包含 11 个时长在一小时左右的讲座，每一个讲座都会关注一个特定的主题或者工具。

3.主题1：`The Shell`

为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：`Shell`,它允许你执行程序，输入并获取某种半结构化的输出。

4.使用shell

bash:

```
zjx@linux-OSCA:~$	#用户名为zjx@linux-OSCA 当前目录为~ $表示现在的身份不是root用户
```

![ ](Linux/131.png)

- 执行了 `date` 这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递 *参数* ：

- 上例中，我们让 shell 执行 echo ，同时指定参数 hello。
- 但是，shell 是如何知道去哪里寻找 `date` 或 `echo` 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在  shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是  shell 所了解的编程关键字，那么它会去咨询 *环境变量*  `$PATH`，它会列出当 shell 接到某条指令时，进行程序搜索的路径：

![ ](article/132.png)

如果希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 `\` 进行处理（`My\ Photos`）。

> 2024年 01月 03日 星期三 16:22:15 CST

哈哈，我突然搞懂了环境变量是个啥，一下子感觉都非常的简单。

```
export MYSLIDE_HOME=/home/zjx/Documents/Repo/ppt_markdown
```

- export: 这是一个 shell 命令，用于设置或显示环境变量。在这里，它用于设置环境变量。

- `MYSLIDE_HOME`: 这是环境变量的名称。

- `/home/zjx/Documents/Repo/ppt_markdown`: 这是为环境变量 `MYSLIDE_HOME` 指定的值，即设置 `MYSLIDE_HOME `的路径`/home/zjx/Documents/Repo/ppt_markdown`。

```
export MYSLIDE_HOME=/home/zjx/Documents/Repo/ppt_markdown
export MYSLIDE_SCRIPT=$MYSLIDE_HOME/scripts
alias pptopen="$MYSLIDE_SCRIPT/open.sh $1"
```

我知道了使用一个程序时，只需要输入它的绝对路径即可，我就想到了这个`pptgen`也是同样的道理,先利用`MYSLIDE_SCRIPT`环境变量提供路径，再执行shell脚本。

> 以 .sh 结尾的文件通常是 Shell 脚本文件。这种文件包含一系列 Shell 命令，可以由操作系统的命令解释器（例如 Bash、sh、zsh 等）执行。 Shell 脚本被用于自动化和批处理任务，其中包含一系列要在终端中执行的命令。 Shell 脚本文件中的命令按顺序执行，可以包括变量、条件语句、循环等结构，使其具有较强的编程能力。

`Bash`（`Bourne Again SHell`）和 `Zsh`（`Z Shell`）都是类Unix系统中的命令行解释器，也被称为`shell`。`Shell`是用户与操作系统内核之间的接口，它允许用户通过命令行或脚本与操作系统进行交互。

Shell的主要功能包括：

- 命令解释与执行： 用户可以通过Shell输入命令，Shell会解释并执行这些命令。

- 脚本编写： 用户可以编写Shell脚本，将一系列命令组织在一起以完成特定的任务。

- 环境控制： Shell可以设置和管理环境变量，影响系统和用户的行为。

- 文件操作： 用户可以使用Shell执行文件和目录的操作，如创建、删除、移动、复制等。

`Bash`是`Unix`和`Linuz`中最常用的默认`Shell`，而`Zsh`则是一个功能更丰富且用户友好的替代品。它们都支持命令行历史、自动补全、别名等功能，以提高用户在命令行环境中的效率和便利性。选择使用哪种Shell通常取决于个人偏好和需求。

学习shell的过程：

shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 `/` 分割，而在Windows上是 `\`。路径 `/` 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如： `C:\`）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 `/` 开头，那么它是一个 *绝对路径*，其他的都是 *相对路径* 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 `pwd` 命令来获取。此外，切换目录需要使用 `cd` 命令。在路径中，`.` 表示的是当前目录，而 `..` 表示上级目录：

![ ](article/191.png)

在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！

最简单的重定向是 `< file` 和 `> file`。这两个命令可以将程序的输入输出流分别重定向到文件：

还可以使用 `>>` 来向一个文件追加内容。使用管道（ *pipes* ），我们能够更好的利用文件重定向。 `|` 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：

![ ](article/193.png)

还可以使用 `>>` 来向一个文件追加内容。使用管道（ *pipes* ），我们能够更好的利用文件重定向。 `|` 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：

![ ](article/196.png)

![ ](article/195.png)



```
$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 > brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
```

出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 `sudo` 命令！关于 shell，有件事我们必须要知道。`|`、`>`、和 `<` 是通过 shell 执行的，而不是被各个程序单独执行。 `echo` 等程序并不知道 `|` 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， *shell* (权限为您的当前用户) 在设置 `sudo echo` 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。

明白这一点后，我们可以这样操作：

```
$ echo 3 | sudo tee brightness
```
