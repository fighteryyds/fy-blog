# Linux studying (一切皆文件)

## 常用命令:

```
1.cd ~  #回到用户目录

2.cd /   #回到根目录

3.cd..   #返回

4.cd../..  #返回上上级目录

5.ls      #显示目录内容列表

6.ll         #列出所有文件

7.pwd   #显示当前目录

8.ctrl + c  #临时强制退出/停止命令的执行

9.touch 文件名   #创建文件

10.df       #显示已挂载的所有磁盘使用情况（用k表示内存）

11.df-h     #显示已挂载的所有磁盘使用情况（用G表示内存）比上一个常用

12.vim      #打开并可编辑文件

13.sort 文件名   #将文件中的内容按从1到n的先后顺序排列展示，但不会改变原文件

14.sort -n 文件名  #按数字大小进行排序

15.sort -nr 文件名 #倒叙排列文件内容

16.cp -i 你想复制的文件 你想复制到的文件

17.mv 原名 新名  #改名

18.mv 文件现在的绝对路径 文件新的绝对路径 #改变地址

19.rm -i 文件名 #彻底删除（慎重使用）

20.sudo mount /dev/sro/mnt/ #挂载

21.sudo umount /mnt      #解除挂载

22.cat 文件名  #查看文件

23.less 文件名  #查看文件（可翻页）

24.kill+PID #结束进程

25.mkdir temp  #创建一个目录temp

26.cp ../newfile . #将上级目录中的文件newfile复制到当前目录下

27.cp newfile aaa  #将文件newfile复制为新文件aaa

28.mv aaa bbb  #将文件aaa重命名为bbb

29.mv bbb ..  #将文件bbb移动到上级目录

30.rm bbb  #删除文件bbb

31.rm -r temp #递归删除目录temp
```

## 在Linux如何分屏:

1.终端中使用

```
sudo qpt install tmux
```

2.输入tmux进入

3.上下分屏：

```
ctrl+b再按"
```

4.左右分屏：

```
ctrl+b再按%
```

5.切换选中屏幕中的内容：

```
ctrl+b再按o      #英文字母o不是数字0
```

6.切换两个相邻的屏幕：

```
ctrl=b再按{或者}，一个向前切换，一个向后切换。
```

## 在Linux中永久调整大小比例的命令：

```
gsettings set org.gnome.desktop.inerface scaling-factor 2
```

- 其中最后的2是倍数，改成1.5，即1.5倍

## 统计与查找：

1.如果想知道当前目录下究竟有多少行代码，可以在命令行中键入如下命令：

```
find . | grep '\.c$\|\.h$' | xargs wc -l
```

2.find是搜索目录中的文件，<MARK>find .</MARK>表示列出当前目录下的所有文件，按Ctrl+C退出。

3.正则表达式：

- 3.1正则表达式使用单个字串来描述，匹配一系列对应某个句法规则的字符串。（一个字符串匹配其他字符串）
- 3.2以行为单位进行字符串的处理，可以完成查找，替换和删除操作。
- 3.3正则表达式在Linux中一般分为两种，基础正则表达式和扩展正则表达式，扩展正则表达式提供了群组功能。
- 3.4Linux中有些命令是支持正则表达式的：

```
grep, sed , awk
```

- 3.5基础正则表达式的一些语法和工具及一些特殊的特性：

   3.5.1语系是什么？语系就是我们所使用的编码方式，我们知道在不同编码方式中同一字符对应的源二进制码是不同的，而正则表达式在底层中是匹配二进制码所以不同的语系，同一正则表达式匹配的模式可能是不同的。

   3.5.2引用鸟哥的例子来解释语系：

    LANG=C时，编码顺序为：ABCD…Zabcd…z
   
    LANG=zh_CN时，编码顺序为：aAbBcC…zZ
   
    在这里当我们使用[a-z]时，LANG=C选取的是所有小写英文字母，而LANG=zh_CN选取的结果包括大写字母，所以一定要注意使用正则表达式时的语系。
   
    一般我们使用正则表达式所使用的语系是LANG=C

而正则表达式为了避免语系对输出结果的影响，设置了一些特殊字符，匹配特定的字符，在不同语系下的结果是相同的。
 ![在这里插入图片描述](Linux/11202.jpg)

<MARK>这个用法像极了C语言中的 ctype.h 作为头文件引用的一系列函数，它们的功能是计算指定符号的个数，例如大写字母，小写字母，空格，TAB的个数。</MARK>

3.5.3接下来我认为应该是重点，<mark>grep</mark>终于出场了

- <mark>grep</mark>实现了输入的过滤，grep命令是以行为单位来查找字符串的，下面是它的一些语法：

```
1|grep [-acinvA] PATTERN filename
2|-a：将二进制文件以文本文件的方式查找数据
3|-c：计算找到 对应字符 的次数
4|-i：查找时忽略大小写的区别
5|-v：反向查找，即输出不匹配的行
6|-n：输出时输出行号
7|--color=auto：找的的关键字部分加上颜色的显示
8|-A：后面可加数字n，除了列出该行外，后续的n行也列出来
9|-B：后面可加数字n，除了列出该行外，前面的n行也列出来
```

具体该如何简单的使用呢？展示一个例子

输入：

```
grep -in printf ex8  #grep -语法参数 你要查找的内容 文件名
```

输出：

![](Linux/1120.1.jpg)

它会将所有的printf高亮，但是因为我的terminal中并没有行数，所以它并没有输出行数。

3.5.4使用<mark>find</mark>加<mark>grep</mark>来筛选文件（比如以<mark>.c</mark>和<mark>.h</mark>结尾的文件）：

管道符号<mark>|</mark>是关键，<mark>A | B</mark>的含义是创建两个进程A和B, 并将`A`进程的标准输出连接到`B`进程的标准输入.

3.5.5eg:筛选当前目录下以.c结尾的文件：

第一种命令：

```
find .|grep .c   #查找所有以.c结尾的文件
```

我的电脑上的结果展示：

![ ](Linux/11211.jpg)

我发现了另一种更实用的命令（它更简洁方便）：

```
ls *.c   #列出当前目录下所有.c文件
```

![ ](Linux/11212.jpg)

3.5.6我们最后的任务就是统计这些文件所占用的总行数：

`wc`命令的`-l`选项能够计算代码的行数（可在<mark>man wc</mark>中查看）. 

`xargs`命令十分特殊, 它能够将标准输入转换为参数, 传送给第一个参数所指定的程序. 所以, 代码中的`xargs wc -l`就等价于执行`wc -l aaa.c bbb.c include/ccc.h ...`, 最终完成代码行数统计.

利用`xargs`搭配管道符号`|`就可以计算多个文件的总行数。

- 计算一个文件中的行数的命令：

```
wc -l filename
```

- 计算当前目录下多个指定文件(以.c为例)的总行数的命令：

```
ls *.c | xargs wc -l
```

在我的电脑上的展示如图：

![ ](Linux/11213.jpg)

它会把当前目录的所有.c文件的行数列出，并且会计算所有文件的总行数。

当然利用`ls -l`就可以计算当前目录所有文件的情况，`ls *.h`可以计算所有.h文件的情况。

### 统计磁盘使用情况：

我以我的Documents下的目录为例，统计此目录下各个目录所占用的磁盘空间。命令：

```
du -sc ~/Documents/* | sort -nr | less 
```

```
#du是磁盘空间分析工具, du -sc将目录的大小顺次输出到标准输出, 继而通过管道传送给sort. sort是数据排序工具, 其中的选项-n表示按照数值进行排序, 而-r则表示从大到小输出. sort可以将这些参数连写在一起.
```

最后的less工具很好用，当目录过多无法再一个屏幕内全部显示时可以添加“<mark>| less</mark>”来实现翻页 B 是向上翻页，空格是向下翻页。

我的电脑的结果展示：

第一个是Documents目录中的目录：

![ ](Linux/11222.jpg)

然后是/usr/share目录中的各个目录：

![ ](Linux/11223.jpg)

### 在LInux上编写Hello World程序：

1.首先创建一个目录

```
cd ~
mkdir Templates
```

2.然后键入

```
cd Templates
```

3.使用vim开始编辑

```
vi hello.c
```

4.手敲完代码后，按Esc退出insert模式，进入命令模式，然后输入wq+回车，保存并退出。

展示我的电脑上的结果：

![ ](Linux/11224.jpg)

就像第一次用c在windows敲出Hello World一样，内心十分激动。

## 使用重定向：

使用命令将程序输出保存到文件当中（以我上次在Linux中编写的Hello World程序为例）：

<mark>`>`是标准输出重定向符号</mark>

首先为尝试了它给我的命令：

```
objdump -d hello> output
```

可结果却并不是我想要的，此时就体现了实践的重要性了，因为这个重定向看似只是一些命令而已，你可能就会放弃实践，认为它很简单，只需要再使用的时候看一下就可以，可是当你使用的时候它却并不是你想要的结果。

![ ](Linux/1291.jpg)

我想了想./不是运行代码程序吗，于是我使用了命令：

```
./hello > output 
```

哈哈，我获得了我想要的结果：

![ ](Linux/1292.jpg)

如果你希望输出到文件的同时也输出到屏幕上, 你可以使用`tee`命令:

```
./hello | tee output
```

使用输出重定向还能很方便地实现一些常用的功能, 例如

```
1|> empty                  # 创建一个名为empty的空文件
2|cat old_file > new_file  # 将文件old_file复制一份, 新文件名为new_file
```

data文件：可以将程序要读取的内容提前写入data文件，这样如果你需要多次键入大量相同的数据，就可以节省了大量的时间.

我以一个求平方从程序为例：

平方程序：

![ ](Linux/1293.jpg)

data文件内的输入：

![ ](Linux/1294.jpg)

Terminal：

![ ](Linux/1295.jpg)

可以看到效果很明显！

选看1.time工具：

```
1|time ./pinfang < data | tee output
```

`time`工具记录了这一过程所消耗的时间, 最后你会在屏幕上看到`pinfang`运行所需要的时间. 如果你只关心`pinfang`的运行时间, 你可以使用以下命令将`pinfang`的输出过滤掉:

```
time ./pinfang < data > /dev/null
```

在我的电脑上的效果展示：

![ ](Linux/1296.jpg)

选看2.EOF

- 在C语言中，EOF 表示 "End of File"，它是一个特殊的宏，通常被定义为一个负数，用于表示文件结束的标志。在标准输入（stdin）中，当到达文件末尾时，scanf 函数会返回 EOF。

- 在第一个程序中，循环的条件是 scanf("%d", &num) != EOF，这表示当 scanf 未能成功读取一个整数时，即到达文件末尾时，循环将终止。

- 让我们看一下这个条件的工作方式：

scanf("%d", &num) 尝试从标准输入中读取一个整数，并将其存储在变量 num 中。
如果成功读取一个整数，scanf 返回成功读取的项目数（在这里是1）。
如果到达文件末尾（或者发生读取错误），scanf 返回 EOF。
所以，scanf("%d", &num) != EOF 这个条件的含义是：“只要 scanf 成功读取一个整数，就继续循环；如果到达文件末尾或者发生读取错误，就退出循环”。

在这个特定的例子中，当 scanf 返回 EOF 时，意味着已经读取完输入数据，因此循环结束。这是一种通常用于处理文件输入的常见模式。

## 使用Makefile管理工程

大规模的工程中通常含有几十甚至成百上千个源文件(Linux内核源码有25000+的源文件), 分别键入命令对它们进行编译是十分低效的.  Linux提供了一个高效管理工程文件的工具: GNU Make. 我们首先从一个简单的例子开始, 考虑上次提到的Hello World的例子, 在`hello.c`所在目录下新建一个文件`Makefile`, 输入以下内容并保存:

![ ](Linux/12101.jpg)

返回命令行, 键入`make`

![ ](Linux/12102.jpg)

因为我已经使用过命令`make hello`所以它已经是最新的文件了

然后我删除了hello.c重新创建一下看看是什么效果：

![ ](Linux/12103.jpg)

你会发现`make`程序调用了`gcc`进行编译. `Makefile`文件由若干规则组成, 规则的格式一般如下:

```
1|目标文件名:依赖文件列表
2|	用于生成目标文件的命令序列   # 注意开头的tab, 而不是空格
```

我们来解释一下上文中的`hello`规则. 这条规则告诉`make`程序, 需要生成的目标文件是`hello`, 它依赖于文件`hello.c`, 通过执行命令`gcc hello.c -o hello`来生成`hello`文件.

如果你连续多次执行`make`, 你会得到"文件已经是最新版本"的提示信息, 这是`make`程序智能管理的功能. 如果目标文件已经存在, 并且它比所有依赖文件都要"新", 用于生成目标的命令就不会被执行. 你能想到`make`程序是如何进行"新"和"旧"的判断的吗?

上面例子中的`clean`规则比较特殊, 它并不是用来生成一个名为`clean`的文件, 而是用于清除编译结果, 并且它不依赖于其它任何文件. `make`程序总是希望通过执行命令来生成目标, 但我们给出的命令`rm hello`并不是用来生成`clean`文件, 因此这样的命令总是会被执行. 你需要键入`make clean`命令来告诉`make`程序执行`clean`规则, 这是因为`make`默认执行在`Makefile`中文本序排在最前面的规则. 但如果很不幸地, 目录下已经存在了一个名为`clean`的文件, 执行`make clean`会得到"文件已经是最新版本"的提示. 解决这个问题的方法是在`Makefile`中加入一行`PHONY: clean`, 用于指示"`clean`是一个伪目标". 这样以后, `make`程序就不会判断目标文件的新旧, 伪目标相应的命令序列总是会被执行.
